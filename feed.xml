<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-03-29T10:12:53+00:00</updated><id>/feed.xml</id><title type="html">Paulo Villela</title><subtitle>Thoughts on Software Architecture and Engineering</subtitle><entry><title type="html">Containers, Kubernetes, and Service Mesh in a Nutshell</title><link href="/architecture/software-engineering/programming/2021/03/28/Containers_Kubernetes_and_Service_Mesh_in_a-Nutshell.html" rel="alternate" type="text/html" title="Containers, Kubernetes, and Service Mesh in a Nutshell" /><published>2021-03-28T17:56:26+00:00</published><updated>2021-03-28T17:56:26+00:00</updated><id>/architecture/software-engineering/programming/2021/03/28/Containers_Kubernetes_and_Service_Mesh_in_a%20Nutshell</id><content type="html" xml:base="/architecture/software-engineering/programming/2021/03/28/Containers_Kubernetes_and_Service_Mesh_in_a-Nutshell.html">&lt;p&gt;This is a very brief distillation of the concepts around containers, Kubernetes, and service mesh.  The reader is assumed to have passing familiarity with these three terms.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;containers&quot;&gt;Containers&lt;/h3&gt;

&lt;p&gt;Containers are a virtualization technology that enables processes to run in isolation from each other on the same host.  Containers are lighter-weight than virtual machines and enable more efficient utilization of computing capacity.  All containers running on a host share the host’s operating system kernel, but each container chooses its own individual libraries and respective versions (which need to be compatible with the kernel version).  Container hosts are usually (but not always) virtual machines.&lt;/p&gt;

&lt;p&gt;There are several concepts associated with containers that need to be understood.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Container image&lt;/em&gt;&lt;/strong&gt; is a binary file that contains the code (as a filesystem bundle, analogous to a binary tar file) that runs in a container.  There are different container image formats, most notably the Docker format which was adopted by the &lt;a href=&quot;https://opencontainers.org/about/overview/&quot;&gt;Open Container Initiative (OCI)&lt;/a&gt; as its standard format.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Container instance&lt;/em&gt;&lt;/strong&gt; is a process that runs a container image in isolation from other processes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Container runtime&lt;/em&gt;&lt;/strong&gt; is the process that launches container instances and controls their lifecycle.  A container runtime has an API to support the management of container instances and images.  Examples include &lt;a href=&quot;https://containerd.io/&quot;&gt;containerd&lt;/a&gt; and &lt;a href=&quot;https://www.docker.com/products/container-runtime&quot;&gt;Docker Engine&lt;/a&gt;.  Docker Engine actually wraps containerd and exposes the Docker Engine API to Docker clients.  There are other container runtimes, like &lt;a href=&quot;https://cri-o.io/&quot;&gt;CRI-O&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Container runtime client&lt;/em&gt;&lt;/strong&gt; is a command line interface or other kind of application that interacts with the container runtime to manage containers, images, and their lifecycles.  An example is the Docker command line interface (included in Docker Engine).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Image creation and management tools&lt;/em&gt;&lt;/strong&gt; support the creation of container images.  Docker’s &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile&lt;/a&gt; and associated tools is an example, but there are others like &lt;a href=&quot;https://docs.docker.com/develop/develop-images/build_enhancements/&quot;&gt;BuildKit&lt;/a&gt;, &lt;a href=&quot;https://buildah.io/&quot;&gt;Buildah&lt;/a&gt;, and &lt;a href=&quot;https://github.com/GoogleContainerTools/kaniko&quot;&gt;Kaniko&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Image registry&lt;/em&gt;&lt;/strong&gt; is a repository that stores container images with versioning.  &lt;a href=&quot;https://docs.docker.com/docker-hub/&quot;&gt;Docker Hub&lt;/a&gt; is a well-known public registry.  Enterprises maintain their private image registries using &lt;a href=&quot;https://docs.docker.com/registry/deploying/&quot;&gt;Docker Registry Server&lt;/a&gt;, &lt;a href=&quot;https://jfrog.com/container-registry/&quot;&gt;JFrog&lt;/a&gt;, &lt;a href=&quot;https://help.sonatype.com/repomanager3/formats/docker-registry&quot;&gt;Nexus&lt;/a&gt;, &lt;a href=&quot;https://goharbor.io/&quot;&gt;Harbour&lt;/a&gt;, products from cloud providers, and others.&lt;/p&gt;

&lt;h3 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt; (abbreviated as K8s) is a container orchestration engine.  K8s is the &lt;em&gt;de facto&lt;/em&gt; standard for container orchestration,  Based on the &lt;a href=&quot;https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/&quot;&gt;Borg&lt;/a&gt; technology donated by Google, K8s is developed and maintained by the &lt;a href=&quot;https://www.cncf.io/&quot;&gt;Cloud Native Computing Foundation (CNCF)&lt;/a&gt;, which is part of the &lt;a href=&quot;https://www.linuxfoundation.org/&quot;&gt;Linux Foundation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Container orchestration&lt;/em&gt;&lt;/strong&gt; is defined as the capability to define, deploy, and operate a compute cluster consisting of multiple virtual machines or physical servers to launch containers and manage their lifecycle.&lt;/p&gt;

&lt;p&gt;It is important to note that the execution unit orchestrated by Kubernetes is a &lt;em&gt;pod&lt;/em&gt;, not a container.  A &lt;strong&gt;&lt;em&gt;pod&lt;/em&gt;&lt;/strong&gt; consists of one or more containers that are deployed and managed as a unit by K8s.  Often, a pod has a single container.  In some cases, however, there are containers that closely depend on each other and should be part of the same pod.  This is the case when using a service mesh.&lt;/p&gt;

&lt;p&gt;Just as a container is the runtime manifestation of a container image, a pod is the runtime manifestation of a &lt;em&gt;pod spec&lt;/em&gt;.  A &lt;strong&gt;&lt;em&gt;pod spec&lt;/em&gt;&lt;/strong&gt; defines, among other things, the image(s) for the container(s) in the pod.&lt;/p&gt;

&lt;p&gt;Kubernetes’s capabilities include:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Providing the abstractions of &lt;em&gt;deployment&lt;/em&gt; and &lt;em&gt;service&lt;/em&gt; to facilitate the launching and management of multiple instances of the same pod.&lt;/li&gt;
  &lt;li&gt;Managing the number of instances for each pod.&lt;/li&gt;
  &lt;li&gt;Constraining the computation resources allocated to each pod.&lt;/li&gt;
  &lt;li&gt;Allocating work (load balancing) across pods in the same service.&lt;/li&gt;
  &lt;li&gt;Automatically restarting pods instances when they crash.&lt;/li&gt;
  &lt;li&gt;Providing configuration facilities for pods.&lt;/li&gt;
  &lt;li&gt;Providing data persistence facilities for pods.&lt;/li&gt;
  &lt;li&gt;Providing the &lt;em&gt;namespace&lt;/em&gt; abstraction to group related pods (e.g., part of the same application) and isolate them from pods in other namespaces.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;service-mesh&quot;&gt;Service Mesh&lt;/h3&gt;

&lt;p&gt;Service mesh is a technology that augments service orchestration by providing the ability to monitor and mediate interactions between pods.  This can be accomplished by adding so-called &lt;em&gt;sidecar&lt;/em&gt; containers to pods.  A &lt;strong&gt;&lt;em&gt;sidecar&lt;/em&gt;&lt;/strong&gt; is a container that intercepts traffic to and from the main container in the pod.&lt;/p&gt;

&lt;p&gt;Through sidecars and virtual networking, the service mesh can add capabilities such as:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Monitoring of interactions among services.&lt;/li&gt;
  &lt;li&gt;Tracing of interactions among services.&lt;/li&gt;
  &lt;li&gt;Service decorators such as timeout, retry, and circuit-breaker.&lt;/li&gt;
  &lt;li&gt;Authentication and encryption of service interactions with &lt;a href=&quot;https://wott.io/blog/tutorials/2019/09/09/what-is-mtls&quot;&gt;mTLS&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Routing rules.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to providing system administration and operations benefits, service meshes also help to simplify application code by externalizing technical concerns.&lt;/p&gt;

&lt;p&gt;Service mesh architectures are typically described in terms of a &lt;em&gt;data plane&lt;/em&gt; and a &lt;em&gt;control/management plane&lt;/em&gt;.  The &lt;strong&gt;&lt;em&gt;data plane&lt;/em&gt;&lt;/strong&gt; is responsible for intercepting the data traffic to/from containers and acting upon such traffic (sending monitoring/trace messages, encrypting, routing, etc.).  The &lt;strong&gt;&lt;em&gt;control/management plane&lt;/em&gt;&lt;/strong&gt; is responsible for supporting the system administrator by providing configuration facilities and collecting/displaying system state and management information sent by the data plane.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://istio.io/&quot;&gt;Istio&lt;/a&gt; and &lt;a href=&quot;https://linkerd.io/&quot;&gt;Linkerd&lt;/a&gt; are popular service mesh implementations.  &lt;a href=&quot;https://openservicemesh.io/&quot;&gt;Open Service Mesh&lt;/a&gt; is an up-and-coming CNCF sandbox project.&lt;/p&gt;

&lt;h3 id=&quot;references-and-further-reading&quot;&gt;References and further reading&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cncf.io/&quot;&gt;Cloud Native Computing Foundation (CNCF)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/&quot;&gt;A Practical Introduction to Container Terminology&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opencontainers.org/about/overview/&quot;&gt;Open Container Initiative&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://computingforgeeks.com/docker-vs-cri-o-vs-containerd/&quot;&gt;Docker vs CRI-O vs Containerd&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@avijitsarkar123/docker-and-oci-runtimes-a9c23a5646d6&quot;&gt;Docker and OCI Runtimes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.capitalone.com/tech/cloud/container-runtime/&quot;&gt;A Comprehensive Container Runtime Comparison&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/container-runtimes/&quot;&gt;Kubernetes container runtimes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://istio.io/&quot;&gt;Istio&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://linkerd.io/&quot;&gt;Linkerd&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://openservicemesh.io/&quot;&gt;Open Service Mesh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://servicemesh.es/&quot;&gt;Service Mesh Comparison&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://learning.oreilly.com/library/view/the-enterprise-path/9781492089353/&quot;&gt;The Enterprise Path to Service Mesh Architectures, 2nd Edition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>PV</name></author><category term="architecture" /><category term="software-engineering" /><category term="programming" /><summary type="html">This is a very brief distillation of the concepts around containers, Kubernetes, and service mesh. The reader is assumed to have passing familiarity with these three terms.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="/jekyll/update/2021/03/28/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2021-03-28T17:56:26+00:00</published><updated>2021-03-28T17:56:26+00:00</updated><id>/jekyll/update/2021/03/28/welcome-to-jekyll</id><content type="html" xml:base="/jekyll/update/2021/03/28/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>